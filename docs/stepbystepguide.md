# Step-by-step guide.
​
## Step1 - Follow the installation guide

In order to use the **program manager** the following is required:
​
* Follow the installation guide [](doc/InstallationGuide.md)
* Install FIWARE and cygnus microserices
* Install robot program manager microservices
​
## Step 2 - Configuration
​
During the installation check that the environment variables are set as follows:
 * FIREWARE_SERVER_IP IP of the node running FIWARE and Cygnus
 * FIREWARE_SERVER_PORT=1026 port of the FIWARE
 * ROBOT_IP=127.0.0.1 IP of robot communication port
 * ROBOT_PORT=10003 port of the robot 

## Step 3 - Send a program definition to the FIWARE Orion Context Broker

A **program definition** is an entity to be stored in the FIWARE Orion Context Brocker
It represents a robot program that is composed of multiple trajectories that could be divided into several layers.
For a detailed explanation of this entity check the [User & Programmers Manual](docs/usermanual.md)

Send the **program definition** entity to the FIWARE Context Broker: 

```json
"curl http:127.0.1:1026/v2/entities[
    {
      "id": "bfd1d41b-7437-4479-8498",
      "type": "laminationDefinition",
      "partId": "test_01",
      "comment": "program for superficial treatment process",
      "robot": "Elfin5",
      "estimatedExecutionTime": "65.000",
      "programInput": {
        "partId": "mixed_geometry",
        "comment": "  _  ",
        "robot": "Elfin5",
        "home": [ 0.000, -0.053, -1.610, 0.000, -1.584, 0.000 ],
        "robotPose": [ 0.000, 0.000, 0.000, 0.000, 0.000, 0.000 ],
        "piecePose": [ 0.000, 0.000, 0.000, 0.000, 1.571, 0.000 ],
        "tools": [          
          {
            "name": "roller",
            "tcp": [ -26.597, 59.309, 236.000, -0.008, 0.005, -1.149 ]
          },
          {
            "name": "sphere",
            "tcp": [ -24.551, 54.747, 236.000, 0.000, 0.000, 0.422 ]
          }
        ],
        "layers": [
          {
            "layerNumber": 1,
            "trajectories": [
              {
                "tool": "sphere",
                "pathPoses": [
                  [ -442.624, 87.069, 74.161, 2.790, -0.126, -0.034 ],                  
                  [ -626.188, 17.750, 30.014, -2.255, -2.187, 0.000 ],
                  [ -626.188, 17.750, 75.014, -2.255, -2.187, 0.000 ]
                ],
                "stopMessage": "Put sphere on the robot",
                "velocity": "20.000"
              },
              {
                "tool": "sphere",
                "pathPoses": [
                  [ -426.598, -49.327, 72.000, -2.211, 2.232, 0.000 ],
                  [ -426.598, -49.327, 27.000, -2.211, 2.232, 0.000 ],
                  [ -426.598, -49.327, 14.500, -2.211, 2.232, 0.000 ],                 
                  [ -425.752, 41.608, 75.000, -2.211, 2.232, 0.000 ]
                ],
                "stopMessage": "",
                "velocity": "20.000"
              }
            ]
          }
        ]
      }
    }  

]
```
## Step 4 - Manage the robot program definition through the **program manager**

 * Open the link http://localhost:81/ on a webwroser
 * The **Robot Program Manager** application should open:
 
    ![](/assets/robot_program_manager_01.png)

 * On the robot program definitions table are listed the **program definition** entities.
   On the Robot column, we can open the **Robot** column to select the post-processor that we want to select to build the robot program executable. Usually, the name of the postprocessor matches the name of the robot for which we want to generate the executable but we could have several postprocessors for the same robot model.
   * If we press the build button a robot program entity is going to be created by the selected post-processor.
   * This robot entity just created appears on the right table **Robot programs**
 * On the **Robot programs table** the **robot program** entities are managed:
   * The new program just defined could be downloaded to the robot memory.
   * After the robot program is tested on the robot it could suffer some modifications to adapt it to the real robot environment or even entire new branches of code.
   * After the robot program is validated on the robot if the program has had changes it can be uploaded back to the **FIREWARE**.
   * Finally, press on the red label "not validated" to the state "validated" to indicate that this program could safely be deployed for production.

## Step 5 - Get the robot program entity generated by the Post-Processor

Use the id of the program_definition (program_definition_id = bfd1d41b-7437-4479-8498) to  retrieve from the Orion Context Broker the robot programs generated for the program definition:

```
curl http:127.0.1:1026/v2/entities?laminationDefinitonId=bfd1d41b-7437-4479-8498&options=keyValues
```

The **robot program** entity generated by the post-processor microservice has the following form:


```
{
  "id": "5d51f7ae-e72e-4276-ac70-10ee816d9179",
  "type": "laminationRobotProgram",
  "laminationDefinitonId": "bfd1d41b-7437-4479-8498",
  "partId": "test_01",
  "comment": "Elfin5 program for superficial treatment process",
  "robot": "Elfin5",
  "estimatedExecutionTime": "65.000",
  "validated": true,
  "programCode": "PD94bWwgdmVyc2lvbj0iMS4m90SUQ9nQ9IjAiIC8+CjxGdW5", 
  "programEncoding": "base64"
}
```
Where:
 * **programCode** is the robot program generated by the post-processor given by **robot** and that is encoded with the method signaled by the property **programEncoding**
 * **validated** is set to true if the robot program has already been validated and therefore can be used for normal production